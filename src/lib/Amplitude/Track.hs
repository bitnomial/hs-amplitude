{-# LANGUAGE DataKinds #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE OverloadedRecordDot #-}
{-# LANGUAGE OverloadedStrings #-}

module Amplitude.Track (
    -- * Types
    AmplitudeClient (..),
    AmplitudeEventSubmitRequest (..),
    AmplitudeEvent (..),
    AmplitudeResponse (..),
    AmplitudeApiKey (..),
    Http2API,

    -- * Smart constructors
    mkEventWithUserId,
    createClient,
    http2Client,
    trackEvent,
) where

import Control.Monad.IO.Class (liftIO)
import Data.Aeson (
    FromJSON,
    ToJSON,
    Value,
    object,
    withObject,
    (.:),
    (.=),
 )
import Data.Aeson qualified as Aeson
import Data.Map (Map)
import Data.Maybe (fromMaybe)
import Data.Proxy (Proxy (..))
import Data.Text (Text)
import GHC.Generics (Generic)
import Network.HTTP.Client.TLS (newTlsManager)
import Servant.API (
    JSON,
    Post,
    ReqBody,
    (:>),
 )
import Servant.Client (
    ClientEnv,
    ClientError,
    ClientM,
    client,
    mkClientEnv,
    parseBaseUrl,
    runClientM,
 )

data AmplitudeClient = AmplitudeClient
    { apiKey :: AmplitudeApiKey
    , servantEnv :: ClientEnv
    }

newtype AmplitudeApiKey = AmplitudeApiKey {unApiKey :: Text}

createClient :: AmplitudeApiKey -> IO AmplitudeClient
createClient key = do
    manager <- newTlsManager
    let baseUrl = fromMaybe (error "Invalid hardcoded URL") $ parseBaseUrl "https://api2.amplitude.com"
        env = mkClientEnv manager baseUrl
    pure $ AmplitudeClient key env

-- | Request body for Amplitude HTTP API V2
data AmplitudeEventSubmitRequest = AmplitudeEventSubmitRequest
    { apiKey :: Text
    , events :: [AmplitudeEvent]
    }
    deriving (Show, Generic)

instance ToJSON AmplitudeEventSubmitRequest where
    toJSON req =
        object
            [ "api_key" .= req.apiKey
            , "events" .= req.events
            ]

-- | the "main" api to submit events is just 2/httpapi. pretty unusual
type Http2API =
    "2"
        :> "httpapi"
        :> ReqBody '[JSON] AmplitudeEventSubmitRequest
        :> Post '[JSON] AmplitudeResponse

-- | Internal client function generated by servant-client
http2Client :: AmplitudeEventSubmitRequest -> ClientM AmplitudeResponse
http2Client = client (Proxy :: Proxy Http2API)

{- | An Amplitude event
Requires: event_type and at least one of user_id or device_id
-}
data AmplitudeEvent = AmplitudeEvent
    { eventType :: Text
    , userId :: Maybe Text
    , deviceId :: Maybe Text
    , time :: Maybe Integer -- milliseconds since epoch
    , eventProperties :: Map Text Value
    , userProperties :: Map Text Value
    , sessionId :: Maybe Integer
    , insertId :: Maybe Text
    }
    deriving (Show, Generic)

instance ToJSON AmplitudeEvent where
    toJSON evt =
        object $
            filter
                (notNull . snd)
                [ "event_type" .= eventType evt
                , "user_id" .= userId evt
                , "device_id" .= deviceId evt
                , "time" .= time evt
                , "event_properties" .= eventProperties evt
                , "user_properties" .= userProperties evt
                , "session_id" .= sessionId evt
                , "insert_id" .= insertId evt
                ]
      where
        notNull Aeson.Null = False
        notNull _ = True

-- | Response from Amplitude HTTP API V2
data AmplitudeResponse = AmplitudeResponse
    { code :: Int
    , eventsIngested :: Int
    , payloadSizeBytes :: Int
    , serverUploadTime :: Integer
    }
    deriving (Show, Generic)

instance FromJSON AmplitudeResponse where
    parseJSON = withObject "AmplitudeResponse" $ \v ->
        AmplitudeResponse
            <$> v .: "code"
            <*> v .: "events_ingested"
            <*> v .: "payload_size_bytes"
            <*> v .: "server_upload_time"

newtype AmplitudeError = AmplitudeError ClientError
    deriving (Show)

-- | Create an event with a user ID
mkEventWithUserId :: Text -> Text -> Map Text Value -> Map Text Value -> AmplitudeEvent
mkEventWithUserId eventName uid eventProps userProps =
    AmplitudeEvent
        { eventType = eventName
        , userId = Just uid
        , deviceId = Nothing
        , time = Nothing
        , eventProperties = eventProps
        , userProperties = userProps
        , sessionId = Nothing
        , insertId = Nothing
        }

trackEvent :: AmplitudeClient -> AmplitudeEvent -> IO (Either AmplitudeError AmplitudeResponse)
trackEvent ampClient event = do
    liftIO $
        runClientM (http2Client req) ampClient.servantEnv >>= \case
            Left err -> pure . Left $ AmplitudeError err
            Right resp -> pure $ Right resp
  where
    req = AmplitudeEventSubmitRequest ampClient.apiKey.unApiKey [event]
