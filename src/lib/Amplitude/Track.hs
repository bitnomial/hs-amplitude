{-# LANGUAGE DataKinds #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE OverloadedRecordDot #-}
{-# LANGUAGE OverloadedStrings #-}

module Amplitude.Track (
    -- * Types
    AmplitudeClient (..),
    AmplitudeEventSubmitRequest (..),
    AmplitudeEvent (..),
    AmplitudeResponse (..),
    AmplitudeApiKey (..),
    Http2API,

    -- * Smart constructors
    mkEventWithUserId,
    createClient,
    http2Client,
    trackEvent,
) where

import Data.Aeson (
    FromJSON,
    ToJSON,
    Value,
    object,
    withObject,
    (.:),
    (.=),
 )
import Data.Aeson qualified as Aeson
import Data.Bifunctor qualified as B
import Data.Functor ((<&>))
import Data.Map (Map)
import Data.Proxy (Proxy (..))
import Data.Text (Text)
import Data.Time.Clock as C
import Data.Time.Clock.POSIX (POSIXTime)
import GHC.Generics (Generic)
import Network.HTTP.Client.TLS (newTlsManager)
import Servant.API (
    JSON,
    Post,
    ReqBody,
    (:>),
 )
import Servant.Client (
    ClientEnv,
    ClientError,
    ClientM,
    client,
    mkClientEnv,
    parseBaseUrl,
    runClientM,
 )

data AmplitudeClient = AmplitudeClient
    { apiKey :: AmplitudeApiKey
    , servantEnv :: ClientEnv
    }

newtype AmplitudeApiKey = AmplitudeApiKey {unApiKey :: Text}
    deriving (Show, Generic, ToJSON, Eq, Ord)

createClient :: AmplitudeApiKey -> IO AmplitudeClient
createClient key = do
    manager <- newTlsManager
    baseUrl <- parseBaseUrl "https://api2.amplitude.com"
    pure $ AmplitudeClient key (mkClientEnv manager baseUrl)

-- | Request body for Amplitude HTTP API V2
data AmplitudeEventSubmitRequest = AmplitudeEventSubmitRequest
    { apiKey :: AmplitudeApiKey
    , events :: [AmplitudeEvent]
    }
    deriving (Show, Generic)

instance ToJSON AmplitudeEventSubmitRequest where
    toJSON req =
        object
            [ "api_key" .= req.apiKey
            , "events" .= req.events
            ]

-- | the "main" api to submit events is just 2/httpapi. pretty unusual
type Http2API =
    "2"
        :> "httpapi"
        :> ReqBody '[JSON] AmplitudeEventSubmitRequest
        :> Post '[JSON] AmplitudeResponse

-- | Internal client function generated by servant-client
http2Client :: AmplitudeEventSubmitRequest -> ClientM AmplitudeResponse
http2Client = client (Proxy :: Proxy Http2API)

{- | An Amplitude event
Requires: event_type and at least one of user_id or device_id
-}
data AmplitudeEvent = AmplitudeEvent
    { eventType :: Text
    , userId :: Maybe Text
    , deviceId :: Maybe Text
    , time :: Maybe POSIXTime
    , eventProperties :: Map Text Value
    , userProperties :: Map Text Value
    , sessionId :: Maybe Integer
    , insertId :: Maybe Text
    }
    deriving (Show, Generic)

instance ToJSON AmplitudeEvent where
    toJSON evt =
        object $
            filter
                (notNull . snd)
                [ "event_type" .= eventType evt
                , "user_id" .= userId evt
                , "device_id" .= deviceId evt
                , "time" .= fmap posixTimeToMillis evt.time
                , "event_properties" .= eventProperties evt
                , "user_properties" .= userProperties evt
                , "session_id" .= sessionId evt
                , "insert_id" .= insertId evt
                ]
      where
        notNull Aeson.Null = False
        notNull _ = True

posixTimeToMillis :: POSIXTime -> Integer
posixTimeToMillis t = round (C.nominalDiffTimeToSeconds t / 1000000000)

-- | Response from Amplitude HTTP API V2
data AmplitudeResponse = AmplitudeResponse
    { code :: Int
    , eventsIngested :: Int
    , payloadSizeBytes :: Int
    , serverUploadTime :: Integer
    }
    deriving (Show, Generic)

instance FromJSON AmplitudeResponse where
    parseJSON = withObject "AmplitudeResponse" $ \v ->
        AmplitudeResponse
            <$> v .: "code"
            <*> v .: "events_ingested"
            <*> v .: "payload_size_bytes"
            <*> v .: "server_upload_time"

newtype AmplitudeError = AmplitudeError ClientError
    deriving (Show)

-- | Create an event with a user ID
mkEventWithUserId :: Text -> Text -> Map Text Value -> Map Text Value -> AmplitudeEvent
mkEventWithUserId eventName uid eventProps userProps =
    AmplitudeEvent
        { eventType = eventName
        , userId = Just uid
        , deviceId = Nothing
        , time = Nothing
        , eventProperties = eventProps
        , userProperties = userProps
        , sessionId = Nothing
        , insertId = Nothing
        }

trackEvent :: AmplitudeClient -> AmplitudeEvent -> IO (Either AmplitudeError AmplitudeResponse)
trackEvent ampClient event = do
    runClientM (http2Client req) ampClient.servantEnv <&> B.first AmplitudeError
  where
    req = AmplitudeEventSubmitRequest ampClient.apiKey [event]
